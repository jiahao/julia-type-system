\section{Case study: completely pivoted LU}

Linear algebra is ubiquitous in technical computing applications. At the same
time, the implementation of linear algebra libraries is generally considered a
difficult problem best left to the experts. A popular reference book for
numerical methods famously wrote, for example, that ``the solution of
eigensystems... is one of the few subjects covered in this book for which we do
\textit{not} recommend that you avoid canned routines''~\cite[Section 11.0, p.
461]{Press1992}. While much effort has been invested in making
numerical linear algebra libraries
fast~\cite{LAPACK,Gunnels2001,OpenBLAS,VanZee2013}, one nevertheless will
occasionally need an algorithm that is not implemented in a
standard linear algebra library.

One such nonstandard algorithm is the completely pivoted LU factorization. This
algorithm is not implemented in standard linear algebra libraries in
LAPACK~\cite{LAPACK}, as the conventional wisdom is the gains in numerical
stability in complete pivoting is no generally worth the extra effort over
other variants such as partial pivoting~\cite{Golub2013}.  Nevertheless, users
may want complete pivoting for comparison with other algorithms for a
particular use case. For example, one may be interested in comparing the
results of an infinite dimensional LU factorization to its finite-dimensional
approximation, in which case only the completely pivoted LU is defined in both
cases~\cite{Townsend2014}.

In this section, we consider various implementation of completely pivoted LU in
pure Julia. First, we implement the algorithm na\"ively as a direct translation
from the textbook description, and compare the performance with na\"ive
implementations in other high level languages that are commonly used for
technical computing, such as MATLAB, Octave, Python/NumPy, and R. Second, we
rewrite the na\"ive Julia implementation for better performance, and
demonstrate the effects of each transformation on execution time. We believe
that this work flow reflects typical use cases of high level dynamic languages,
where users first write na\"ive but verifiably correct implementations, then
rewrite the implementation until sufficient performance can be achieved.



\subsection{Na\"ive textbook implementation}

Algorithm~\ref{alg:lucompletepiv} presents the textbook description of the LU
factorization with complete pivoting~\cite[Algorithm 3.4.3 (Outer Product LU
with Complete Pivoting), p. 132]{Golub2013}, and below it a direct translation
into a na\"ive Julia implementation. This algorithm is presented in MATLAB-like
pseudocode, and contains a mixture of scalar \lstinline|for| loops and
MATLAB-style vectorized indexing operations that describe various subarrays of
the input matrix $A$. Additionally, there is a description for the subproblem
of finding the next pivot at the start of the loop. Furthermore, the pseudocode
uses the $\leftrightarrow$ operation, denoting swaps of various rows and
columns of $A$. To translate the pivot finding subproblem into Julia, we used
the built-in \lstinline|indmax| function to find the linear index of the value
of the subarray \lstinline|A[k:n, k:n]| which has the largest magnitude, then
used the \lstinline|ind2sub| function to convert the linear index to a tuple
index. The $\leftrightarrow$ operator was implemented using vectorized indexing
operations, as is standard practice in high level languages like MATLAB.



\begin{algorithm}

\caption{Top: Textbook pseudocode describing the $LU$ factorization with
complete pivoting~\cite[Algorithm 3.4.3 (Outer Product LU with Complete
Pivoting), p. 132]{Golub2013}. The matrix $A$ is overwritten in-place with the
$LU$ factors, with $rowpiv$ and $colpiv$ containing the row and column pivots
respectively.
Bottom: An implementation of $LU$ factorization with complete pivoting in Julia,
which returns the result as a tuple. The ! at the end of the function name is
convention for a function with side effects (in this case, mutating $A$).
Unicode characters such as Greek letters and the $\ne$ operator are allowed in
Julia code, allowing for close notational correspondence with the textbook
description of the algorithm.}
\label{alg:lucompletepiv}

\begin{algorithmic}
\For {$k = 1:n - 1$}

    Determine $\mu, \lambda$ where $k \le \mu \le n$,  $k \le \lambda \le n$, so

    $\quad\left|A(\mu, \lambda)\right| = \max\{ \left|A(i, j)\right| : i=k:n, j=k:n \}$

    $rowpiv(k) = \mu$

    $A(k, 1:n) \leftrightarrow A(\mu, 1:n)$

    $colpiv(k) = \lambda$

    $A(1:n, k) \leftrightarrow A(1:n, \lambda)$

    \If{$A(k,k) \ne 0$}

        $\rho = k+1:n$

        $A(\rho, k) = A(\rho, k)/A(k, k)$

        $A(\rho, \rho) = A(\rho, \rho) - A(\rho, k) A(k, \rho)$
    \EndIf
\EndFor
\end{algorithmic}

\hrulefill

\begin{lstlisting}
function lucompletepiv!(A)
	n=size(A, 1)
	rowpiv=zeros(Int, n-1)
	colpiv=zeros(Int, n-1)
	for k=1:n-1
		Asub = abs(A[k:n, k:n]) #Search for next pivot
		$\mu$, $\lambda$ = ind2sub(size(Asub), indmax(Asub))
		$\mu$ += k-1; $\lambda$ += k-1
		rowpiv[k] = $\mu$
		A[[k, $\mu$], 1:n] = A[[$\mu$, k], 1:n]
		colpiv[k] = $\lambda$
		A[1:n, [k, $\lambda$]] = A[1:n, [$\lambda$, k]]
		if A[k,k] $\ne$ 0
			$\rho$ = k+1:n
			A[$\rho$, k] = A[$\rho$, k]/A[k, k]
			A[$\rho$, $\rho$] = A[$\rho$, $\rho$] - A[$\rho$, k] * A[k, $\rho$]
		end
	end
	return (A, rowpiv, colpiv)
end
\end{lstlisting}

\end{algorithm}

For comparison purposes, we also wrote na\"ive implementations in other high
level dynamics languages which are popular for technical computing. Here, we
considered MATLAB, Octave, Python/NumPy, and R (whose codes are available in the
Appendix). The codes were executed on a late 2013 MacBook Pro running OS X
Yosemite 10.10.2, with Julia 0.4-dev+3970, MATLAB R2014b, Octave 3.8.1, Python
3.4.3 with NumPy 1.9.2 from the Anaconda 2.1.0 distribution, and R 3.1.3. Where
possible, we also tried to run variants with and without JIT compilation. In
MATLAB, the JIT compiler is on by default, but can be turned off with the
command \lstinline|feature accel off|. Octave's JIT compiler is experimental
and off by default, but can be enable with a command line switch. R provides a
JIT compiler in the \lstinline|compiler| library package. We do not have
JIT-compiled results for Python, as at this time of writing, neither PyPy 2.5.0
nor Numba 0.17.0 was able to compile the code.\footnote{
The specialized fork of NumPy required to run on PyPy 2.5.0 did not build
successfully on neither Python 2.7.9 nor 3.4.3 on OSX. Numba 0.17.0, with the
\lstinline|@jit(nopython=True)| decorator, threw a
\lstinline|NotImplementedError| exception.}
The results are summarized in Figure~\ref{fig:scaling}, which shows the
near-perfect $O(n^3)$ scaling of the algorithm in each implementation, as well
as in Figure~\ref{fig:naivelangs}, which shows the execution times across the
different languages for a $1000 \times 1000$ matrix of \lstinline|Float64|s
with randomly sampled standard Gaussians.



\begin{figure*}
	\includegraphics[width=\textwidth]{data/fig-scaling}
	\caption{Scaling behavior of na\"ive implementation of the completely
	pivoted $LU$ algorithm on $N\times N$ random matrices in Julia, MATLAB,
	Octave, Python/NumPy and R. Julia code is listed in
	Algorithm~\ref{alg:lucompletepiv}, and the others are available in the
	Appendix.} \label{fig:scaling}
\end{figure*}

\begin{figure*}
	\includegraphics[width=\textwidth]{data/fig-lang}
	\caption{Comparison of execution times }
	\label{fig:naivelangs}
\end{figure*}



\subsection{Improving the performance of a na\"ive implementation}


