\section{The Julia Language}
\TODO{Give an overview of the Julia language.}

We have designed the type system to be as permissive as possible to programmers while still providing enough information to statically resolve a significant portion of dispatches. The main contribution of the type system design is that types are values that the programmer can write programs to compute. The challenge in designing such a type system are in specifying how tags can be computed and how the subtyping relationships work. [Question: is this type system based on/similar to any other type system?]
Motivating reason: having types as values allows you to have fewer components to the language design. Lets you write array parametric on a type without explicitly declaring the type parameter.
Main challenges:
- Types/tags exist to describe things in a standard way. Challenge to think about what needs to be described. Canonical example for long time was arrays with different element types.
[What were the main difficulties in designing the type system?]
[What about promoters? Do type promotions show up in other languages?]
Type promotions are written as user-level code to compute new types.

\subsection{Types in Julia}
The defining feature of dynamic typing is that all values, semantically at least, have
two parts: a \emph{tag} and some \emph{data}. The tag classifies the value according to
some ontology defined by the programming language, and the data is a block of memory
whose format is set by the programming language, possibly in a way that depends on the
tag.

Colloquially tags are typically called ``types'' by programmers, as the distinction
is not important in most uses of dynamic typing. In type theory each tag corresponds
one-to-one to a type encoding the proposition that some term evaluates to a value
with that tag. However dynamically-typed languages usually do not require that such
a type system be used. Statically determining all tags is generally not possible.
Furthermore, it would be perfectly reasonable to impose a static type system that
was not concerned with tags at all, but rather with other program properties
(e.g. checking for possible uses of null references). Tags are a mechanism, and as
such neither require nor preclude any particular formalism.

Tags are valuable because they have a constrained structure. While the data
part of a value may vary arbitrarily at run time, tags are drawn from a limited,
well-understood family. This provides for self-describing data: it becomes possible
to write a program that accepts an \emph{arbitrary} value, discovers its structure,
and operates on it, by examining its tag.

The potential of tags is to provide a common descriptive language shared by all users
of a language, as well as the compiler. The cost of tags is overhead. The addition of
a tag may double, or more, the memory footprint of a data item. Partly for this reason,
most dynamically typed languages try to simplify and minimize their tag systems.
(Laurence Tratt also points out that tags tend to resemble the types used in static
languages, likely as a result of cultural expectations \cite{}.) Taken to an extreme,
as in Scheme, the set of possible tags might be finite and small, allowing tags to be
overlaid with pointer bits in many implementations.

Julia tries to reach the other extreme, providing for tags with nested structure, and
possibly containing arbitrary values.

- describing when code is applicable (dispatch)
- describing what to specialize on
- describing memory layout
- describing what, if anything, is statically known about a potential value

\paragraph{Type inference is a key part of the language}
A somewhat unusual feature of julia is that we consider dataflow type inference a
key part of the language. Strictly speaking, this is an optional, external program
analysis that might be used for various purposes, chief among them implementing
an optimizing compiler. However, it is highly important to programmers since it
largely defines not the semantics, but the performance model of the language.

We feel that dataflow analysis, especially of forward flow, captures a piece of
the human intuition of how programs work: values start at the top and move through
the program step by step. For example, compilers are much more user-friendly
when they elide a possibly-uninitialized variable warning in

\begin{minted}[frame=lines,framesep=2mm]{julia}
int a;
if (cond)
    a = 1;
else
    a = 2;
f(a);
\end{minted}

The programmer knows that \code{a} is always initialized before use.
