\section{Discussion}

\subsection{Why is dynamic multiple dispatch useful for numerical computing?}

If the matrix is composed of floating point types that BLAS and
LAPACK routines can handle, the function call is dispatched onto an
appropriate BLAS/LAPACK routine. Yet if the matrix contains other
numeric types, such as rational numbers or quaternions, Julia provides
generic methods which handle the computations using standard textbook
algorithms. In this way, multiple dispatch allows the widest possible
set of inputs while not giving up the ability to use handcrafted
performant kernels when they are available.

The ability to perform multiple dispatch dynamically is valuable
when you can specialize on certain algorithms but you can only
determine which algorithm to dispatch on at runtime. This is useful
for linear algebraic applications where certain properties of an input
matrix are difficult to determine \textit{a priori}, such as matrix
symmetries like Hermiticity, or spectral properties like positive
definiteness. The matrix square root function (\code{sqrtm}) uses
runtime multiple dispatch to check if the input matrix is symmetric
(for real element types) or Hermitian (for complex element types). If
the matrix is symmetric/Hermitian, \code{sqrtm} dispatches on a
specialized method to compute the principal matrix square root using
the eigenvalues and eigenvectors, otherwise a different method is
dispatched upon which computes and uses the Schur factorization
instead. The \code{factorize} function in Julia is another, more
extreme example of how dynamic multiple dispatch can be used to detect
matrix symmetries and structure (e.g. if a matrix is diagonal,
symmetric tridiagonal, upper triangular, etc.) and compute appropriate
matrix factorizations that best take advantage of the detected matrix
structure.

\TODO{Other possible examples from Distributions.jl: QQ plots, posterior function}

\subsection{External dispatch with dynamic multimethods}

One thing you can do with dynamic multiple dispatch is external dispatch,
i.e.\ to be able to add new methods to an existing type rather than
specifying all the possible methods upfront. This is used to good effect
in Julia packages to extend functionality of the base library. For example,
the package \package{Color.jl} for manipulating color spaces extends the
\code{writemime} base function, which writes an object as a specified
MIME type\cite{mimerfc} to an I/O stream. \code{Color.jl} extends
\code{writemime} with new methods that draw color swatches.

\TODO{Here, we could put a figure showing writemime being called on a base
Julia object, writemime(::Color), and writemime(::VectorColor) objects.
Possibly take a screenshot in IJulia.}

External dispatch also facilitates interaction between Julia packages--- 
colors can be rendered using the \package{Cairo.jl} package,
which allows rendering to a Cairo backend~\cite{cairographics}.
When using Cairo to render an object in a given color, \code{Cairo.jl}
doesn't need to know anything about the underlying color space; it just
needs to call \code{convert} methods provided by \code{Color.jl}.
Julia's \code{convert} protocol is the ``narrow waist'' that allows
packages to allow using all kinds of color spaces naturally, without
needing to know anything specifically about them.

External dispatch can be performed in other languages like C++. However,
C++ only allows static external dispatch, which severely limits its utility.
Furthermore, external dispatch in C++ requires virtual methods and visitor
patterns\cite{designpatterns} to work around the absence of explicit support
for external dispatch.

\TODO{Talk about the psychological implications of types.}
