\section{The Julia Type System}

\begin{quote}
  \textit{Ceci n'est pas une type} \\
  (With apologies to H. Magritte)
\end{quote}

\subsection{Basics}
\TODO{This is where we write one of those trees.}

\paragraph{What is a type?}
Types are values in Julia.

\paragraph{Dataflow analysis}

\paragraph{Subtyping relations and the type lattice}

\paragraph{\code{typeof}}

You can define \code{typeof} axiomatically as having the following behavior on a \code{value=(bits, tag)} pair:

\begin{minted}[frame=lines,framesep=2mm]{julia}
typeof(bits, tag) = (tag, DataType) #Returns a value
\end{minted}

\code{typeof} has a fixed point, namely \code{(DataType, DataType)}. This is also true in other dynamic languages, e.g. Python (CPython). In other languagues like Haskell, \code{typeof(DataType) = Kind}, etc. Static languages can just truncate the tower of metatypes and also refuse to typecheck code that reasons about types and kinds too far up the hierarchy. In fact, early versions of Haskell did not allow for programs to reason about kinds at the data type level due to the lack of kind polymorphism~\cite{haskellkindtypes}.

\TODO{There is a subtletly about typeof's behavior. typeof is a projection; typeof(not-a-type) produces a DataType, which projects non-type values onto types. It also has the effect of lifting non-type values onto a type lattice; the latter is defined only for values that are DataTypes.}

\paragraph{Widening}

\TODO{Formal proof of correctness?}

\subsection{Dispatch}

\paragraph{method sorting for specificity}

\TODO{The main novelty and challenge is explaining type parameters and typevars. Currently typevars are not first-class objects in Julia; you can't pass them to a function. Expressions of the form \code{T<:SomeType} don't have an independent existence outside a function signature that also contains the \code{\{T...\}} construction.}

\subsection{Type Inference}

\subsection{Type promotion}

\subsection{Example: modular integer arithmetic with \code{lcm}}

Here's an example of a type parameter computed with the \code{lcm} function:

\begin{minted}[frame=lines,fontsize=\footnotesize,
               framesep=2mm]{julia}
import Base: convert, promote_rule, show, showcompact

immutable ModInt{n} <: Integer
    k::Int
    ModInt(k) = new(mod(k,n))
end

-{n}(a::ModInt{n}) = ModInt{n}(-a.k)
+{n}(a::ModInt{n}, b::ModInt{n}) = ModInt{n}(a.k+b.k)
-{n}(a::ModInt{n}, b::ModInt{n}) = ModInt{n}(a.k-b.k)
*{n}(a::ModInt{n}, b::ModInt{n}) = ModInt{n}(a.k*b.k)

convert{n}(::Type{ModInt{n}}, k::Int) = ModInt{n}(k)
convert{n}(::Type{ModInt{n}}, k::ModInt) = ModInt{n}(k.k)
promote_rule{n}(::Type{ModInt{n}}, ::Type{Int}) = ModInt{n}
promote_rule{m,n}(::Type{ModInt{m}}, ::Type{ModInt{n}}) =
    ModInt{lcm(m,n)}

show{n}(io::IO, k::ModInt{n}) = print(io, "$(k.k) mod $n")
showcompact(io::IO, k::ModInt) = print(io, k.k)

julia> a = ModInt{12}(18278176231)
7 mod 12

julia> b = ModInt{15}(2837628736423)
13 mod 15

julia> a + b
20 mod 60
\end{minted}

The type of the result \code{a + b} depends on the types of \code{a} and \code{b} via \code{lcm}.
