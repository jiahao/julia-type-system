\section{The Julia Type System}

\begin{quote}
  \textit{Ceci n'est pas une type} \\
  (With apologies to H. Magritte)
\end{quote}

Julia has no static semantics, and therefore everything it does must be dynamically describable.

In Julia all compiler values are pairs of a value v and a type tag T. Julia
values are essentially equivalent of what is sometimes called dynamic
types~\cite[Section 11.10, p. 142]{Pierce2002}

\paragraph{Subtyping relations and the type lattice}

Julia requires allows user-defined types to have exactly one declared supertype.
If no supertype is declared explicitly, the supertype is assumed to be \code{Any}.

The subtype relations define a lattice of types~\cite{Scott1977}. Furthermore
the lattice is bounded by a top type, \code{Any}, from above and a bottom
type, \code{Union()}, below.

We inherit the meet and join operations on the type lattice.

\paragraph{Kinds of types}
Julia has different kinds of types which can be formally summarized as:

\begin{minted}[frame=lines,framesep=2mm]{sml}
Type ::= Abstract | Data | Tuple | ForAll | Union | Singleton
Abstract ::= Name (P) Super }
Data ::= Name (P) Super Repr } invariant, nominative
TODO: What is repr?
Tuple ::= (T1, T2, …) | (T1, T2, …, Tn, …) } covariant
ForAll ::= $\forall$ (lb <: T <: ub) . Type
Union ::= U (T1, T2, …)
Singleton ::= Lift Value
TypeVar ::= lb <: Name <: ub
top ::= Any
--
Tag ::= Data | Tuple
\end{minted}

\begin{description}

\item[Data constructor/Tag types] (Pierce calls these atomic types or base types \cite[Fig.
	11-1, p.118]{Pierce2002}): types whose internal structure are not
	represented by the type system. (ACTUALLY I don't think this is true
	anymore, since \code{abstract} has no internal structure.) Julia has a
	special kind of tag type called \code{bitstype}s which simply label a
	contiguous number of bits.

??? Are things defined by \code{type} and \code{immutable} also tag types?
This is a different kind of type - they define an internal representation but
they are also abstract data types. These are \textit{abstract data types} that
completely define a different kind of type algebra and method interaction interface.
(These types abstract away the semantics of the containing fields and are not
record types.)

\code{DataType}s have associated inner and outer constructors.

\item[Tuple types] \code{(T1, T2,...)} which are constructed from the Cartesian
product of zero or more existing types \code{T1}, \code{T2}, etc.~\cite[Sec. 11.7]{Pierce2002}
Tuples are covariant.

\item[Abstract types] define a type with no declared representation. Abstract
	types are uninstantiable in the sense that there are no values whose
	types are abstract types. Their primary purpose is as declared
	supertypes of leaf types (which are instantiable); their role in
	providing structure in the type lattice is useful for writing
	multimethod signatures and type inference.

\item[Singleton types] In Julia, singleton types may be specified explicitly as
	using the \code{::Type\{T\}} construct. Singletons are used for
	computations on types themselves, such as type promotions. For example,
	given two types, can ask what the promoted type is. So far haven't had
	singleton types for general values. (Sorting algorithms example: used
	more for dispatch as shorthand for type with no parameters.) Will use
	this more because generating specialized code is big for scientific
	computing, but need to figure out what to specialize on and how to tell
	system what to specialize on. State of the art is to have ad hoc
	systems.

\item[Union types] declared as \code{Union(T1, T2,...)} which can be defined as
	the join of zero, or two or more, types \code{T1}, \code{T2},
	...~\cite[Sec.  15.7]{Pierce2002}
	%
	\begin{equation}
		Union(T_1, T_2, ..., T_N) = \bigwedge_{i=1}^N T_i 
	\end{equation}
	%
	The union with zero types, \code{Union()}, is simply the bottom type.
	%
	Julia's \code{Union}s are untagged and disjoint, which allows for some
	simplifications in their construction:
	\begin{itemize}
		\item If there are types \code{S} and \code{T} obeying the
			subtyping relation \code{S <: T}, then \code{S} is
			deleted from the final union type constructed. Note
			that this simplification includes the special case
			where \code{S} and \code T are identical.  (I think
			this is a $\beta$-reduction.)

		\item A union type \code{Union(T)} with a single type parameter
			\code{T} is identical to just \code{T}. (I think this
			is an $\eta$-reduction.)
	\end{itemize}

\item[\code{TypeVar}] A quantification over a set of types.  ForAll types
	quantify over all types between a lower bound and upper bound. Have
	lower bound and upper bound because of containers that can be read and
	written. People mostly only use the upper bounds. No function types, so
	no contravariance, so lower bounds don't get used much. In theory, can
	still use them for functions that mutate things.

\end{description}

\paragraph{Type parameters}

Parametric types are invariant.

\paragraph{Example of user-definable type}

Example: the \code{Complex} type defined by

\begin{minted}{julia}
immutable Complex{T<:Real} <: Number
    re :: T
    im :: T
end
\end{minted}

has two declared fields, \code{re} and \code{im}. Each of these fields has the
type annotation \code{::T}. The type parameter \code{T} is constrained to be a
subtype of \code{Real}, and \code{Complex} itself has a declared supertype
which is \code{Number}.

\code{Complex} comes with a default, implicitly defined inner constructor

\mint{julia}|Complex{T<:Number}(re::T, y::T) = new(re, im)|
%
which makes use of a special intrinsic function \code{new} to allocate new
memory for the fields \code{re} and \code{im}. Inner constructors can be
defined by the user, in which case the default inner constructor is not
generated.

An instance of \code{Complex} can be created using the inner constructor, e.g.\

\mint{julia}|z = Complex{Float64}(0.0, 1.0)|

whose fields can be accessed directly as \code{P.x} and \code{P.y} respectively~
\footnote{\code{P.x} is desugared into the equivalent Julia code \code{getfield(P, x)}.
\code{getfield} is Julia's field accessor function.}

\paragraph{Nonobvious consequences}

A nonobvious consequence of the invariance of type parameters is that
parametric types can be instantiated with any type parameter regardless of
whether it is abstract or concrete.

The three \code{Complex} numbers

\begin{minted}{julia}
z1 = Complex{Float64}(0.0, 1.0)
z2 = Complex{FloatingPoint}(0.0, 1.0)
z3 = Complex{Union(Rational, Integer, Float64)}(0, 1.0)
\end{minted}

are all numerically equivalent (i.e.\ \code{z1 == z2 == z3}), but they are not
identical (in the \textit{egal} sense).

If we inspect the variables using Julia's \code{dump} command, we get:

\begin{minted}{jlcon}
julia> dump(z1)
Complex{Float64} 
  re: Float64 0.0
  im: Float64 1.0

julia> dump(z2)
Complex{FloatingPoint} 
  re: Float64 0.0
  im: Float64 1.0

julia> dump(z3)
Complex{Union(Integer,Float64,Rational{T<:Integer})} 
  re: Int64 0
  im: Float64 1.0

\end{minted}

We see that the \code{::T} annotation on a field does not guarantee that the
type of a value placed in the field in any given instance of that type is
exactly of type \code{T}, merely that it is a subtype of \code{T}.

An abstract type declares a type without a representation. It takes the name of a type, parameters [what do the parameters do?], and the name of the super type. Data type declarations additionally provide a representation. \TODO{Talk about the representation.}
Abstract type and data type declarations are invariant and nominative.

\subsection{Basics}
\TODO{This is where we write one of those trees.}

Can write procedures to subtype.

Jeff is pretty sure subtyping is decidable and well-defined
Join is union of any two types; meet is less well-defined in this lattice

How does types as value play into this description?
What are types in Julia?
Dynamically typed.
What is inheritance like?
How does Julia avoid problems that OO languages tend to have with dispatch? (I'm not actually sure what they are.)
Is there multiple inheritance?
No, but it's been discussed (https://github.com/JuliaLang/julia/issues/5)
Is there multiple subtyping?
No, each type has only one supertype
We should also describe the dispatch mechanism.
Method tables are a sorted list of these types.
Implemented as \code{jl\_methtable\_t}

\paragraph{Dataflow analysis}

What is the goal of the dataflow analysis? Primarily for static type inference. Eliminate runtime checks. Lattice-based. Kaplan-Ullman.
Problem is finding the tightest possible set of allowable types.
There are tweaks to the standard algorithm. One big thing is that dataflow analysis only goes in forward direction.
Kaplan-Ullman also doesn't treat parametric types
Julia also has a widening step.
Relies on types having only one supertype.
Diagonal dispatch: can constrain arguments to same type.

\TODO{What are the challenges?}

\TODO{What is the complexity?}

\TODO{What is the best way to express this?}

\TODO{bit of background}

\paragraph{Subtyping relations and the type lattice}

\paragraph{\code{typeof}}

You can define \code{typeof} axiomatically as having the following behavior on a \code{value=(bits, tag)} pair:

\begin{minted}[frame=lines,framesep=2mm]{julia}
typeof(bits, tag) = (tag, DataType) #Returns a value
\end{minted}

\code{typeof} has a fixed point, namely \code{(DataType, DataType)}. This is also true in other dynamic languages, e.g. Python (CPython). In other languages like Haskell, \code{typeof(DataType) = Kind}, etc. Static languages can just truncate the tower of metatypes and also refuse to type-check code that reasons about types and kinds too far up the hierarchy. In fact, early versions of Haskell did not allow for programs to reason about kinds at the data type level due to the lack of kind polymorphism~\cite{haskellkindtypes}.

\TODO{There is a subtlety about typeof's behavior. typeof is a projection; typeof(not-a-type) produces a DataType, which projects non-type values onto types. It also has the effect of lifting non-type values onto a type lattice; the latter is defined only for values that are DataTypes.}

\paragraph{Widening}

\TODO{Formal proof of correctness?}

\subsection{Dispatch}

\paragraph{method sorting for specificity}

\TODO{The main novelty and challenge is explaining type parameters and typevars. Currently typevars are not first-class objects in Julia; you can't pass them to a function. Expressions of the form \code{T<:SomeType} don't have an independent existence outside a function signature that also contains the \code{\{T...\}} construction.}

\subsection{Type inference}

\subsection{Type promotion}

\subsection{Example: modular integer arithmetic with \code{lcm}}

Here's an example of a type parameter computed with the \code{lcm} function:

\begin{minted}[frame=lines,fontsize=\footnotesize,
               framesep=2mm]{julia}
import Base: convert, promote_rule, show, showcompact

immutable ModInt{n} <: Integer
    k::Int
    ModInt(k) = new(mod(k,n))
end

-{n}(a::ModInt{n}) = ModInt{n}(-a.k)
+{n}(a::ModInt{n}, b::ModInt{n}) = ModInt{n}(a.k+b.k)
-{n}(a::ModInt{n}, b::ModInt{n}) = ModInt{n}(a.k-b.k)
*{n}(a::ModInt{n}, b::ModInt{n}) = ModInt{n}(a.k*b.k)

convert{n}(::Type{ModInt{n}}, k::Int) = ModInt{n}(k)
convert{n}(::Type{ModInt{n}}, k::ModInt) = ModInt{n}(k.k)
promote_rule{n}(::Type{ModInt{n}}, ::Type{Int}) = ModInt{n}
promote_rule{m,n}(::Type{ModInt{m}}, ::Type{ModInt{n}}) =
    ModInt{lcm(m,n)}

show{n}(io::IO, k::ModInt{n}) = print(io, "$(k.k) mod $n")
showcompact(io::IO, k::ModInt) = print(io, k.k)

julia> a = ModInt{12}(18278176231)
7 mod 12

julia> b = ModInt{15}(2837628736423)
13 mod 15

julia> a + b
20 mod 60
\end{minted}

The type of the result \code{a + b} depends on the types of \code{a} and \code{b} via \code{lcm}.
