\section{Introduction}

Dynamically typed languages are popular when computing on data of uncertain formats or with uncertain outcomes. Suppose you have a ten-terabyte dataset. You want to find the parts of it that are useful. The first step is to summarize the data set. There are various tools to summarize the data set \TODO{talk about what these are}, but it is usually not clear which of the tools will produce useful summaries. This process is one of rapid iteration: the programmer must keep trying summary toolchains until there is one that works. \TODO{What does it mean to work?}

Dynamically typed languages are often better suited for this rapid iteration process. In this class of programs, the programming process is one of running experiments rather than one of building robust systems. This is the nature of many scientific programs: programs operating over data sets created by scientific experiments. Scientific programs frequently involve operating over reified data values whose types are difficult to predict. Because it is not always clear what the properties of the data are going to be, it is not clear what the types of the values and which functions to call. \TODO{Be more specific about this?} Writing this code in statically typed languages involves extensive case statements on types and typed enumeration of the possible different cases. The programmer can avoid this in dynamic languages.

We present a solution based around efficient multiple dispatch. Much of the overhead in dynamic languages comes from dynamic lookups of function dispatch. \TODO{Is this actually true?} We present a programming language Julia where the key insight is designing a dispatch mechanism that allows for as much static resolution as possible. Julia programs are organized around multiple dispatch: programs overload functions for different combinations of argument types. The key ingredients in Julia are multi-methods and a static data flow algorithm for type inference. Julia's multi-methods are designed around static analysis to resolve programmer-specific type tags as much as possible. Julia is dynamically typed in that the compiler does not statically reject ill-typed programs, but Julia is designed to optimize static type and dispatch inference.
 \TODO{Figure out how new this idea of type tags is.}\TODO{Contextualize this in existing work.}

In this paper, we describe the Julia language and type system and our implementation of type inference and multiple dispatch mechanisms for Julia. Julia is a high-performance dynamic language with a compiler, distributed parallel execution, numerical accuracy, and an extensive mathematical function library. Julia has a dynamic semantics based on efficient multiple dispatch. Julia combines programmer-specified type tags with a type inference engine to statically optimize method dispatch. We demonstrate [X]x performance improvements over [MATLAB? un-optimized Julia code?]. To demonstrate the relevance and potential impact of designing a language based around multiple dispatch, we also describe the manifestations of multiple dispatch in Julia's standard library.

The main contributions of this paper are as follows:
We describe the multiple dispatch semantics of the Julia language.
We describe our algorithms for statically resolving method dispatches when information is available.
We describe the uses of multiple dispatch in Julia's standard library.
We describe the performance of Julia benchmarks. \TODO{Compare to other numbers.}

\paragraph{Limitations of class-based dispatch for numerics} %TODO These paragraph markings are structural only; take them out later.

Arguably, class-based dispatch is not natural for numeric computations. It's difficult to know upfront all the possible things you want to do to a floating point number.

In languages like C++, you can extend existing classes with new methods, but it's difficult. Need to have virtual methods and invoke template specialization with them. Oftentimes you also need runtime code to decide what kind of object to create.

Static languages like Haskell have typeclasses\cite{typeclass}, but you'll need to anticipate all the necessary use cases ahead of time because everything is resolved statically and also know all the cases you'll be in at compile time. Dynamic languages provide only dynamic bindings,  which means that programmers don't have to reason about the differences between static and dynamic semantics, and dynamic binding is more general anyway.

\paragraph{Dynamic languages, realism and empiricism}

\begin{quote}
Engineers build things; scientists describe reality; philosophers get lost in broad daylight.---\cite{Gabriel2012}
\end{quote}

Arguably, dynamic languages are more in concord with the empirical mode of scientific inquiry that is familiar to users of technical computing, many of whom are also scientists and engineers. Dynamic languages embody a realist philosophy: programs are not checked for correctness, but are executed until termination or when a runtime error is thrown. The focus is to make sense out of whatever program a user may write. In contrast, static languages focus on formal correctness, validating programming on the basis of satisfying constraints imposed by static analyses. Furthermore, these formal systems tend to concern themselves with only the interface to data types, not with their internal representation. Consequently, the formal logic of program correctness does nothing for user concerns about performance, since they abstract away memory layout details which is crucial for understanding the impact of hardware factors such as bus latency and bandwidth.

As a result of the more liberal attitude taken toward program validation, dynamic languages lend naturally to rapid iteration through many prototypes and versions of computer programs. This sort of experimentation in writing programs comes naturally to technical computing users, who often have to write programs without any idea of what the final result ought to look like. Dynamic languages offer a natural expression for these use cases that lack formal specifications, by not imposing upon users the burden of writing formally correct programs, allowing them to focus instead on expressing how to do practical computations.

In other words, a scientist will often run a program in order to find out what it does ---
\emph{proving} anything about what it does would be premature, and an unwelcome distraction.
Of course some such proofs are innocuous, for example that the program will return a
floating-point number. However such proofs are also of no particular interest in the
application domain.

\paragraph{Multiple dispatch allows dispatch on new types and new functions at the same time}

%TODO This is very garbled and mostly reflects my lack of understanding of dispatch systems - cjh

The needs of technical computing can exceed the abilities of most dispatch systems. In particular, it is usually not possible to have new behaviors that intermix new types and new functions. One group of languages allows you to have new types but their dispatch upon existing functions cannot be defined. Subtyping is the usual paradigm here, but it is closed because it assumes you've covered all the cases explicitly. Object oriented programming can be seen as a solution around this problem, but in pure OO, objects have only identity and have no interface protocol. Classes are a mechanism for implementing message sends, defining actions \textit{upon} an object. The other group of languages allows you to have new functions but not for existing types. Haskell typeclasses~\cite{typeclass} are a fixed collection of interfaces; while additional functions can be defined, only the functions that form part of the existing interface can interact with an existing type.

\paragraph{Fewer language constructs for user simplicity}

The original motivation in Julia for having types as values was to simplify the
language for technical computing users. The current design came about from
considering the desire for users to simplify code dealing with parametrically
polymorphic types, i.e. be able to write things like \code{Array} as a synonym
for \code{Array\{T\}}. Such synonyms are valuable for composability when writing 
methods that are agnostic about the type parameter \code{T}. Methods that cared
about \code{T} can be defined with a type signature that explicitly mentions
\code{T} and methods that did not care about \code{T} can have a type signature
that left it out.

%XXX like R? I forgot which language Jeff mentioned
The ability to leave out type parameters in function signatures contrasts with
other languages which require explicit specification of all type parameters,
resulting in users having to write redundant code blocks whose sole purpose is
handle the nuisance parameter. In contrast, the value proposition in Julia is
that having types as values, a collapsed kind hierarchy (i.e.\ making no
distinction between types and kinds (meta-types) and meta-kinds etc.), plus
being able to reason about types dynamically, affords users a way to harmonize
the use of types and pattern matching language constructions that are common in
other languages.
