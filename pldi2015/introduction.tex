\section{Introduction}

\paragraph{Limitations of class-based dispatch for numerics} %TODO These paragraph markings are structural only; take them out later.

Argurably, class-based dispatch is not natural for numeric computations. It's difficult to know upfront all the possible things you want to do to a floating point number.

In languages like C++, you can extend existing classes with new methods, but it's difficult. Need to have virtual methods and invoke template specialization with them. Oftentimes you also need runtime code to decide what kind of object to create.

Static languages like Haskell have typeclasses\cite{typeclass}, but you'll need to anticipate all the necessary use cases ahead of time because everything is resolved statically and also know all the cases you'll be in at compile time. Dynamic languages provide only dynamic bindings,  which means that programmers don't have to reason about the differences between static and dynamic semantics, and dynamic binding is more general anyway.

\paragraph{Dynamic languages, realism and empiricism}

\begin{quote}
Engineers build things; scientists describe reality; philosophers get lost in broad daylight.---\cite{Gabriel2012}
\end{quote}

Arguably, dynamic languages are more in corcord with the empirical mode of scientific inquiry that is familiar to users of technical computing, many of whom are also scientists and engineers. Dynamic languages embody a realist philosophy: programs are not checked for correctness, but are executed until termination or when a runtime error is thrown. The focus is to make sense out of whatever program a user may write. In contrast, static languagues focus on formal correctness, validating programing on the basis of satisfying constraints imposed by static analyses. Furthermore, these formal systems tend to concern themselves with only the interface to data types, not with their internal representation. Consequently, the formal logic of program correctness does nothing for user concerns about performance, since they abstract away memory layout details which is crucial for understanding the impact of hardware factors such as bus latency and bandwidth.

As a result of the more liberal attitude taken toward program validation, dynamic languages lend naturally to rapid iteration through many prototypes and versions of computer programs. This sort of experimentation in writing programs comes naturally to technical computing users, who often have to write programs without any idea of what the final result ought to look like. Dynamic languages offer a natural expression for these use cases that lack formal specifications, by not imposing upon users the burden of writing formally correct programs, allowing them to focus instead on expressing how to do practical computations.

In other words, a scientist will often run a program in order to find out what it does ---
\emph{proving} anything about what it does would be premature, and an unwelcome distraction.
Of course some such proofs are innocuous, for example that the program will return a
floating-point number. However such proofs are also of no particular interest in the
application domain.

\paragraph{Multiple dispatch allows dispatch on new types and new functions at the same time}

%TODO This is very garbled and mostly reflects my lack of understanding of dispatch systems - cjh

The needs of technical computing can exceed the abilities of most dispatch systems. In particular, it is usually not possible to have new behaviors that intermix new types and new functions. One group of languages allows you to have new types but their dispatch upon existing functions cannot be defined. Subtyping is the usual paradigm here, but it is closed because it assumes you've covered all the cases explicitly. Object oriented progrmming can be seen as a solution around this problem, but in pure OO, objects have only identity and have no interface protocol. Classes are a mechanism for implementing message sends, defining actions \exist{upon} an object. The other group of languages allows you to have new functions but not for existing types. Haskell typeclasses~\cite{typeclass} are a fixed collection of interfaces; while additional functions can be defined, only the functions that form part of the existing interface can interact with an existing type.
